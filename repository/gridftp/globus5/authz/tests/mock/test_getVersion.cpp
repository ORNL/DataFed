#define BOOST_TEST_MAIN

#define BOOST_TEST_MODULE getVersion
#include <boost/filesystem.hpp>
#include <boost/test/unit_test.hpp>

#include "Version.hpp"

// Public includes
#include "common/CommunicatorFactory.hpp"
#include "common/CredentialFactory.hpp"
#include "common/DynaLog.hpp"
#include "common/ICredentials.hpp"
#include "common/MessageFactory.hpp"
#include "common/ProtocolTypes.hpp"
#include "common/TraceException.hpp"

// Proto file includes
#include "common/SDMS.pb.h"
#include "common/SDMS_Anon.pb.h"

using namespace SDMS;

extern "C" {
#include "AuthzWorker.h"
}

BOOST_AUTO_TEST_SUITE(mock_liveness_get_version)

BOOST_AUTO_TEST_CASE(mock_liveness_test_get_version) {

  std::string fname = "../../mock_core/mock-datafed-core-key.pub";
  std::string mock_core_server_address = "tcp://localhost:9998";
  std::ifstream inf(fname.c_str());
  if (!inf.is_open() || !inf.good()) {
    EXCEPT_PARAM(1, std::string("Could not open server key file: ") + fname);
  }
  std::string server_key;
  inf >> server_key;
  inf.close();

  std::unordered_map<CredentialType, std::string> cred_options;
  // Public and private keys are consistent with what is in the mock for the
  // repo
  cred_options[CredentialType::PUBLIC_KEY] =
      "Wxwm^-Cf7cJrqS)}/B?cDAq(L=@AwSA*({jhBu1]";
  cred_options[CredentialType::PRIVATE_KEY] =
      "1:BoDR8-#sGZuRWyP*jr+Csm-kT}zV:tn@gRDS.u";
  // Server key can be generated by the mock
  cred_options[CredentialType::SERVER_KEY] = server_key;

  std::cout << "cred public key: " << cred_options[CredentialType::PUBLIC_KEY]
            << std::endl;
  std::cout << "cred private key: " << cred_options[CredentialType::PRIVATE_KEY]
            << std::endl;
  // Server key should be the public key of the mock-datafed-core.pub
  std::cout << "cred server key: " << cred_options[CredentialType::SERVER_KEY]
            << std::endl;

  CredentialFactory cred_factory;
  std::unique_ptr<ICredentials> sec_ctx =
      cred_factory.create(ProtocolType::ZQTP, cred_options);

  // Need to attach a random number to the authz_client_socket so that
  // each authz client is distinct
  std::string authz_thread_id;
  authz_thread_id = "authz_client_socket_test_mock";

  auto client_comm = [&](const std::string &socket_id,
                         const std::string &address,
                         ICredentials &credentials) {
    /// Creating input parameters for constructing Communication Instance
    AddressSplitter splitter(address);

    SocketOptions socket_options;
    socket_options.scheme = splitter.scheme();
    socket_options.class_type = SocketClassType::CLIENT;
    socket_options.direction_type = SocketDirectionalityType::BIDIRECTIONAL;
    socket_options.communication_type = SocketCommunicationType::ASYNCHRONOUS;
    socket_options.connection_life = SocketConnectionLife::INTERMITTENT;
    socket_options.protocol_type = ProtocolType::ZQTP;
    socket_options.connection_security = SocketConnectionSecurity::SECURE;
    socket_options.host = splitter.host();
    socket_options.port = splitter.port();

    std::cout << "Host: " << socket_options.host << std::endl;
    std::cout << "Port: " << std::to_string(socket_options.port.value())
              << std::endl;

    LogContext log_context;
    log_context.thread_name = "mock_core_server_test_client";
    log_context.thread_id = 0;
    if (socket_options.port.has_value()) {
      if (socket_options.port.value() != 9998) {

        DL_WARNING(log_context,
                   "Port number is defined for: "
                       << address
                       << " however, it is a non standard port, the standard "
                          "port for connecting to the mock core server is port "
                          "number 9998, whereas here you are using port: "
                       << socket_options.port.value());
      }
    }
    socket_options.local_id = socket_id;

    // Shortened for testing speed
    uint32_t timeout_on_receive = 2000;
    long timeout_on_poll = 2000;

    CommunicatorFactory comm_factory(log_context);

    return comm_factory.create(socket_options, credentials, timeout_on_receive,
                               timeout_on_poll);
  }(authz_thread_id, mock_core_server_address, *sec_ctx);

  // Correlation id should be created when message is created
  std::string corr_id;
  const std::string id = "MyClientId";
  MessageFactory msg_factory;

  { // Client send an empty payload i.e. an ack
    auto msg_from_client =
        msg_factory.create(MessageType::GOOGLE_PROTOCOL_BUFFER);

    corr_id = std::get<std::string>(
        msg_from_client->get(MessageAttribute::CORRELATION_ID));

    std::cout << "Message correlation id: " << corr_id << std::endl;
    std::cout << "Message id: " << id << std::endl;
    msg_from_client->set(MessageAttribute::ID, id);
    msg_from_client->set(MessageAttribute::KEY,
                         cred_options[CredentialType::PUBLIC_KEY]);

    auto version_req = std::make_unique<Anon::VersionRequest>();

    msg_from_client->setPayload(std::move(version_req));

    client_comm->send(*msg_from_client);
  }

  { // Receive a version response payload
    ICommunicator::Response response =
        client_comm->receive(MessageType::GOOGLE_PROTOCOL_BUFFER);

    std::cout << "Checking message response" << std::endl;

    BOOST_CHECK(response.time_out == false);
    BOOST_CHECK(response.error == false);

    // Only run the following if the unique pointer is valid and a message
    // exists
    if (response.message) {
      std::cout << "Checking matching correlation ids." << std::endl;
      BOOST_CHECK_EQUAL(corr_id, std::get<std::string>(response.message->get(
                                     MessageAttribute::CORRELATION_ID)));

      std::cout << "Key is "
                << std::get<std::string>(
                       response.message->get(MessageAttribute::KEY))
                << std::endl;
      std::cout << "ID is "
                << std::get<std::string>(
                       response.message->get(MessageAttribute::ID))
                << std::endl;
      // BOOST_CHECK(
      //   std::get<std::string>(response.message->get(MessageAttribute::KEY))
      //        .compare(key) == 0);
      // BOOST_CHECK(std::get<std::string>(response.message->get(MessageAttribute::ID)).compare(id)
      // == 0);

      // const auto &routes = response.message->getRoutes();
      // std::cout << "Routes are " << std::endl;
      // for (const auto &route : routes) {
      //  std::cout << route << std::endl;
      //}
      // BOOST_CHECK(routes.size() == 1);
      // BOOST_CHECK(routes.front().compare(client_id) == 0);

      auto google_msg_ptr = std::get<::google::protobuf::Message *>(
          response.message->getPayload());

      Anon::VersionReply *version_response =
          dynamic_cast<Anon::VersionReply *>(google_msg_ptr);

      BOOST_CHECK(version_response->has_release_year());
      BOOST_CHECK(version_response->has_release_month());
      BOOST_CHECK(version_response->has_release_day());
      BOOST_CHECK(version_response->has_release_hour());
      BOOST_CHECK(version_response->has_release_minute());
    } else {
      std::cout << "No message was received." << std::endl;
    }
  }
}

BOOST_AUTO_TEST_SUITE_END()
